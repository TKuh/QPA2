#! @Chapter Ideals

#! @Section Categories for ideals

#!
DeclareCategory( "IsQuiverAlgebraLeftIdeal", IsQuiverAlgebraIdeal );

#!
DeclareCategory( "IsQuiverAlgebraRightIdeal", IsQuiverAlgebraIdeal );

#! @Section Constructing ideals

#! @Description
#!  Create the two-sided ideal generated by the elements <A>gens</A>
#!  in the quiver algebra <A>A</A>.
#! @Returns IsQuiverAlgebraTwoSidedIdeal
#! @Arguments A, gens
DeclareOperation( "QuiverAlgebraTwoSidedIdeal", [ IsQuiverAlgebra, IsDenseList ] );

#! @Description
#!  Create the left ideal generated by the elements <A>gens</A>
#!  in the quiver algebra <A>A</A>.
#! @Returns IsQuiverAlgebraTwoSidedIdeal
#! @Arguments A, gens
DeclareOperation( "QuiverAlgebraLeftIdeal", [ IsQuiverAlgebra, IsDenseList ] );

#! @Description
#!  Create the right ideal generated by the elements <A>gens</A>
#!  in the quiver algebra <A>A</A>.
#! @Returns IsQuiverAlgebraTwoSidedIdeal
#! @Arguments A, gens
DeclareOperation( "QuiverAlgebraRightIdeal", [ IsQuiverAlgebra, IsDenseList ] );

#! @Description
#!  Create the ideal generated by the elements <A>gens</A>
#!  in the quiver algebra <A>A</A>.
#!  The argument <A>side</A> determines whether to create a
#!  left, right or two-sided ideal.
#! @Returns IsQuiverAlgebraTwoSidedIdeal
#! @Arguments side, A, gens
DeclareOperation( "QuiverAlgebraIdeal", [ IsSide, IsQuiverAlgebra, IsDenseList ] );

# DeclareOperation( "LeftIdealByGenerators", [ IsQuiverAlgebra, IsDenseList ] );
# DeclareOperation( "RightIdealByGenerators", [ IsQuiverAlgebra, IsDenseList ] );
# DeclareOperation( "TwoSidedIdealByGenerators", [ IsQuiverAlgebra, IsDenseList ] );

#! @Description
#!  Given a list of <A>relations</A> in a path algebra <A>kQ</A>, the functions returns
#!  concatenation of the list <A>relations</A> and all paths of length <A>n</A> in the
#!  quiver <M>Q</M>.
#! @Returns <C>IsList</C>
#! @Arguments kQ, relations, n
DeclareOperation( "AddNthPowerToRelations", [ IsPathAlgebra, IsHomogeneousList, IS_INT ] );

#! @Description
#!  The functions returns the <A>n</A>-th power of the ideal generated by
#!  the arrows in the path algebra <A>KQ</A> in the quiver <M>Q</M>.
#! @Returns <Ref Filt="IsPathAlgebraIdeal"/>
DeclareOperation( "NthPowerOfArrowIdeal", [ IsPathAlgebra, IS_INT ] );


#! @Section Information about an ideal

#! @Description
#!  Returns the algebra containing the ideal <A>I</A>.
#! @Returns IsQuiverAlgebra
#! @Arguments I
DeclareAttribute( "AlgebraOfIdeal", IsQuiverAlgebraIdeal );

#! @Description
#!  Returns the generators of the ideal <A>I</A>.
#! @Returns list of IsQuiverAlgebraElement
#! @Arguments I
DeclareAttribute( "Generators", IsQuiverAlgebraIdeal );

#! @Description
#!  Checks if <A>I</A> is an admissible ideal.
#! @Returns IsBool
#! @Arguments I
DeclareProperty( "IsAdmissibleIdeal", IsPathAlgebraIdeal );

#! @Description
#!  This function returns true if <A>I</A> is a monomial ideal, 
#!  that is, <A>I</A> is generated by a set of monomials (= "zero-relations").
#! @Returns <C>IsBool</C>
#! @Arguments I
DeclareProperty( "IsMonomialIdeal", IsPathAlgebraIdeal );

#! @Description
#!  Check if <A>I</A> is the zero ideal.
#! @Returns IsBool
#! @Arguments I
DeclareProperty( "IsZeroIdeal", IsQuiverAlgebraIdeal );

#! @Description
#!  Returns the field over which the algebra the ideal is contained in is defined.
#! @Returns <C>IsField</C>
#! @Arguments I
DeclareAttribute( "LeftActingDomain", IsQuiverAlgebraTwoSidedIdeal );

#! @Description
#!  Returns a minimal generating set of the admissible ideal <A>I</A>.
#! @Returns <C>IsList</C>
#! @Arguments I
DeclareOperation( "MinimalGeneratingSetOfIdeal", [ IsPathAlgebraIdeal ] );

#! @Description
#!  This function returns true, if the list of elements <A>gens</A> is a list of 
#!  a quadratic ideal; false otherwise. 
#! @Returns <C>IsBool</C>
#! @Arguments gens
DeclareOperation( "IsQuadraticElements", [ IsHomogeneousList ] );

#! @Section Ideals as modules

#! @Description
#!  The ideal <A>I</A> viewed as a module.
#! @Returns IsQuiverModule
#! @Arguments I
DeclareAttribute( "IdealAsModule", IsQuiverAlgebraIdeal );

#! @Description
#!  The ideal <A>I</A> viewed as a submodule of the algebra.
#!  The result is the inclusion map from the module corresponding to <A>I</A>
#!  into the module corresponding to the algebra.
#! @Returns IsQuiverModuleHomomorphism
#! @Arguments I
DeclareAttribute( "IdealAsSubmoduleOfAlgebra", IsQuiverAlgebraIdeal );

#! @Description
#!  Given an algebra element <A>a</A> which lies in the ideal <A>I</A>,
#!  returns the corresponding module element in <C>IdealAsModule(I)</C>.
#! @Returns IsQuiverModuleElement
#! @Arguments a, I
DeclareOperation( "IdealElementAsModuleElement", [ IsQuiverAlgebraElement, IsQuiverAlgebraIdeal ] );

#! @Description
#!  Given a module element <A>m</A> which lies in the module <C>IdealAsModule(I)</C>,
#!  returns the corresponding algebra element.
#! @Returns IsQuiverAlgebraElement
#! @Arguments m, I
DeclareOperation( "ModuleElementAsIdealElement", [ IsQuiverModuleElement, IsQuiverAlgebraIdeal ] );


#! @Section Basis

#!
# DeclareAttribute( "Basis", IsQuiverAlgebraIdeal );

#!
DeclareCategory( "IsQuiverAlgebraIdealBasis", IsBasis );

#!
DeclareAttribute( "IdealOfBasis", IsQuiverAlgebraIdealBasis );


#! @Section Groebner basis

#! @Arguments I
#! @Returns list of <Ref Filt="IsPathAlgebraElement"/>
#! @Description
#!  A Groebner basis for the ideal <A>I</A>.
DeclareAttribute( "GroebnerBasis", IsPathAlgebraIdeal );

#! @Section Operations on ideals


#! @Description
#!  Given two ideals <A>I</A> and <A>J</A> this function returns the product
#!  ideal <M>IJ</M>, which gets a structure of an ideal according to the input. 
#! @Returns <Ref Filt="IsQuiverAlgebraIdeal"/>
#! @Arguments I, J
#! DeclareOpertation( "ProductSpace", [ IsQuiverAlgebraIdeal, IsQuiverAlgebraIdeal ] );


#